<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Lexington Hydrants</title>

    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>

    <style>
      html, body { height: 100%; margin: 0; }
      #map { height: 100%; width: 100%; }
    </style>
  </head>

  <body>
    <div id="searchBox" style="
      position: absolute; top: 10px; left: 50px; z-index: 2000;
      background: white; padding: 8px; border-radius: 6px;
      box-shadow: 0 1px 6px rgba(0,0,0,0.25); font-family: system-ui, sans-serif;">
      <input id="addr" type="text" placeholder="Search address (Lexington, MA)…" style="width: 280px; padding: 6px;" />
      <button id="go" style="padding: 6px 10px;">Go</button>
    </div>

    <div id="map"></div>

    <script>
      // 1) Map + basemap
      const map = L.map("map").setView([42.447, -71.225], 13);


      let searchMarker = null;

      async function geocode(query) {
        const q = query.includes("Lexington") ? query : `${query}, Lexington, MA`;
        const url = new URL("https://nominatim.openstreetmap.org/search");
        url.searchParams.set("format", "json");
        url.searchParams.set("limit", "1");
        url.searchParams.set("q", q);

        const resp = await fetch(url.toString(), {
          headers: {
            // Nominatim requests that apps identify themselves; include a contact.
            // This is not a secret; it's for abuse/contact purposes.
            "Accept": "application/json"
          }
        });

        if (!resp.ok) throw new Error(`Geocode failed: HTTP ${resp.status}`);
        const results = await resp.json();
        return results[0] || null;
      }

      async function runSearch() {
        const input = document.getElementById("addr").value.trim();
        if (!input) return;

        try {
          const hit = await geocode(input);
          if (!hit) {
            alert("No results.");
            return;
          }

          const lat = parseFloat(hit.lat);
          const lon = parseFloat(hit.lon);

          if (searchMarker) map.removeLayer(searchMarker);
          searchMarker = L.marker([lat, lon]).addTo(map)
            .bindPopup(hit.display_name)
            .openPopup();

          map.setView([lat, lon], 17);
        } catch (e) {
          console.error(e);
          alert("Search failed. Try again.");
        }
      }

      document.getElementById("go").addEventListener("click", runSearch);
      document.getElementById("addr").addEventListener("keydown", (e) => {
        if (e.key === "Enter") runSearch();
      });


        // L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
      // maxZoom: 19,
      // attribution: '&copy; OpenStreetMap contributors'
      // }).addTo(map);

      // Satellite imagery
      const imagery = L.tileLayer(
        "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        { maxZoom: 19, attribution: "Tiles © Esri" }
      ).addTo(map);

      // Put overlays in their own pane above imagery
      map.createPane("labels");
      map.getPane("labels").style.zIndex = 650;
      map.getPane("labels").style.pointerEvents = "none";

      // Roads (vector-ish raster overlay)
      const roads = L.tileLayer(
        "https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Transportation/MapServer/tile/{z}/{y}/{x}",
        { maxZoom: 19, pane: "labels", attribution: "Tiles © Esri" }
      ).addTo(map);

      // Labels (street/place labels overlay)
      const labels = L.tileLayer(
        "https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Reference_Overlay/MapServer/tile/{z}/{y}/{x}",
        { maxZoom: 19, pane: "labels", attribution: "Tiles © Esri" }
      ).addTo(map);

      // 2) Custom hydrant icon
      const hydrantIcon = L.icon({
        iconUrl: "fire_hydrant_64x64.png",
        iconSize: [64, 64],
        iconAnchor: [32, 32],
        popupAnchor: [0, -32]
      });

      const hydrantFile = "Lexington-Hydrants.geojson";

      // 3) Load GeoJSON and add to map
      fetch(hydrantFile)
        .then(r => r.json())
        .then(data => {
          const layer = L.geoJSON(data, {
            pointToLayer: (feature, latlng) => L.marker(latlng, { icon: hydrantIcon }),
            onEachFeature: (feature, lyr) => {
              const p = feature.properties || {};
              // Simple popup: render key fields; extend as you like
              const html = `
                <div style="font-family: system-ui, sans-serif; font-size: 14px; line-height: 1.35;">
                  <div><b>${p.facilityid ?? p.legacy_id ?? "Hydrant"}</b></div>
                  ${p.locdesc ? `<div><b>Location:</b> ${p.locdesc}</div>` : ""}
                  ${p.condition ? `<div><b>Condition:</b> ${p.condition}</div>` : ""}
                  ${p.flow ? `<div><b>Flow (GPM):</b> ${p.flow}</div>` : ""}
                  ${p.manufactur ? `<div><b>Manufacturer:</b> ${p.manufactur}</div>` : ""}
                  ${p.model_no ? `<div><b>Model:</b> ${p.model_no}</div>` : ""}
                  ${p.color ? `<div><b>Color:</b> ${p.color}</div>` : ""}
                  ${p.installdat ? `<div><b>Installed:</b> ${p.installdat}</div>` : ""}
                </div>
              `;
              lyr.bindPopup(html);
            }
          }).addTo(map);

          map.fitBounds(layer.getBounds(), { padding: [20, 20] });
        })
        .catch(err => {
          console.error(err);
          alert(`Failed to load ${hydrantFile}. Check file name/path.`);
        });
    </script>
  </body>
</html>
